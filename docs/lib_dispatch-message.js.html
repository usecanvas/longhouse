<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/dispatch-message.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/dispatch-message.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const createRedisClient = require('./create-redis-client');
const errors            = require('./error-handlers');
const isUUID            = require('validator').isUUID;
const logfmt            = require('logfmt');
const sendMessage       = require('./send-message');
const pubsub            = require('./pubsub');
const redisCmd          = createRedisClient();
const publisher         = createRedisClient();

module.exports = dispatchMessage;

/**
 * Responsible for handling events sent to Longhouse by WebSocket clients.
 * @module dispatchMessage
 */

/**
 * Dispatch a message from the given client to a handler.
 *
 * This function parses the given client message and passes it along to the
 * appropriate handler. If a handler for the message is not found, an error will
 * be sent to the client.
 *
 * This function also validates that the space provided in the message is a v4
 * UUID and that the "identity" parameter is set.
 *
 * When the message has been handled, an acknowledgement message (with,
 * potentially, some metadata) will be sent back to the client.
 *
 * @param {ws.WebSocket} client The client to dispatch a message from
 * @param {String} message The raw message from the client
 */
function dispatchMessage(client, message) {
  try {
    message = JSON.parse(message);
  } catch(err) {
    errors.handleUnparsableMessage(client, message);
    return;
  }

  if (message.action === 'join' &amp;&amp; !isUUID(message.space, '4')) {
    errors.handleNonUUIDSpace(client, message);
    return;
  }

  if (message.action === 'join' &amp;&amp; !message.identity) {
    errors.handleNoIdentityProvided(client, message);
    return;
  }

  if (message.action === 'join' &amp;&amp; client.__meta) {
    errors.handleAlreadyJoined(client, message);
    return;
  }

  if (message.action !== 'join' &amp;&amp; !client.__meta) {
    errors.handleNotJoined(client, message);
    return;
  }

  switch (message.action) {
    case 'join':
      handleMessage(join, client, message);
      break;
    case 'ping':
      handleMessage(ping, client, message);
      break;
    case 'leave':
      handleMessage(leave, client, message);
      break;
    default:
      errors.handleUnrecognizedAction(client, message);
  }
}

/**
 * Handle a message from a client, and log the time it takes to complete.
 *
 * @private
 * @param {String} action The action to be handled
 * @param {ws.WebSocket} client The client that called this action
 * @param {Object} message The parsed message from the client
 */
function handleMessage(action, client, message) {
  const timer = logfmt.time();

  action(client, message, () => {
    timer.log({ event: 'message processed', action: action.name });
  });
}

/**
 * Handle a request for a client to join a space.
 *
 * This sets a key like `spaces.${spaceUUID}.${userIdentity}` in Redis with an
 * expiration.
 *
 * @private
 * @param {ws.WebSocket} client The client that called this action
 * @param {Object} message The parsed message from the client
 * @param {Function} cb A callback to call after the request is fulfilled
 */
function join(client, message, cb) {
  const presenceKey  = getPresenceKey(message.space, message.identity);
  const nsKeyPattern = getNSKeyPattern(message.space);
  const meta         = {};

  client.__meta = meta;

  meta.identity           = message.identity;
  meta.joinedAt           = new Date();
  meta.presenceKey        = presenceKey;
  meta.space              = message.space;

  pubsub.joinClient(client.__meta.space, client);

  redisCmd.multi()
    .set(presenceKey, client.__meta.identity)
    .keys(nsKeyPattern)
    .exec((err, replies) => {
      if (err) {
        errors.handleRedisError(client, err);
        return;
      }

      publisher.publish(`spaces.${meta.space}.join`, meta.identity);

      const presenceKeys = replies[1];
      const members      = presenceKeys.map(extractIdentityFromPresenceKey);
      sendMessage(client, { action: 'join', members: members });
      cb();
    });
}

/**
 * Handle a request for a client to establish that they are still present.
 *
 * This sets a key like `spaces.${spaceUUID}.${userIdentity}` in Redis with an
 * expiration.
 *
 * @private
 * @param {ws.WebSocket} client The client that called this action
 * @param {Object} message The parsed message from the client
 * @param {Function} cb A callback to call after the request is fulfilled
 */
function ping(client, message, cb) {
  client.__meta.joinedAt = new Date();

  process.nextTick(() => {
    sendMessage(client, { action: 'ping' });
    cb();
  });
}

/**
 * Handle a request for a client to leave a space.
 *
 * This deletes a key like `spaces.${spaceUUID}.${userIdentity}` in Redis.
 *
 * @private
 * @param {ws.WebSocket} client The client that called this action
 * @param {Object} message The parsed message from the client
 * @param {Function} cb A callback to call after the request is fulfilled
 */
function leave(client, message, cb) {
  const meta        = client.__meta;
  const presenceKey = getPresenceKey(meta.space, meta.identity);

  pubsub.removeClient(client, meta.space);

  redisCmd.del(presenceKey, err => {
    if (err) {
      errors.handleRedisError(client, err);
      return;
    }

    pubsub.removeClient(client, meta.space);
    publisher.publish(`spaces.${meta.space}.leave`, meta.identity);
    delete client.__meta;
    sendMessage(client, { action: 'leave' });
    cb();
  });
}

function extractIdentityFromPresenceKey(presenceKey) {
  return presenceKey.split('.').slice(2).join('.');
}

function getNSKeyPattern(space) {
  return `spaces.${space}.*`;
}

function getPresenceKey(space, identity) {
  return `spaces.${space}.${identity}`;
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-clientExpirer.html">clientExpirer</a></li><li><a href="module-ClientRegister.html">ClientRegister</a></li><li><a href="module-createRedisClient.html">createRedisClient</a></li><li><a href="module-dispatchMessage.html">dispatchMessage</a></li><li><a href="module-errorHandlers.html">errorHandlers</a></li><li><a href="module-pubsub.html">pubsub</a></li><li><a href="module-sendMessage.html">sendMessage</a></li><li><a href="module-server.html">server</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
